# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VUl3lpxc3VfglXZBPngmDL9mTT5ygOsd
"""

import os
import cv2
import numpy as np
import shutil
from google.colab import drive
import time

# --- 1. Mount Drive ---
drive.mount('/content/drive')

# --- 2. Download Raw Videos (Only runs if needed) ---
if not os.path.exists("/content/UCF101.rar"):
    print("Downloading UCF101.rar (6.5GB)... This will take a few minutes.")
    # We add --no-check-certificate to avoid SSL errors
    !wget --no-check-certificate http://crcv.ucf.edu/data/UCF101/UCF101.rar -O /content/UCF101.rar
else:
    print("UCF101.rar already downloaded.")

# --- 3. Unzip Raw Videos (Only runs if needed) ---
if not os.path.exists("/content/UCF-101"):
    print("Unzipping UCF101.rar... This will take 5-10 minutes.")
    !sudo apt-get install unrar -y
    !unrar x /content/UCF101.rar /content/ -inul
else:
    print("UCF-101 folder already exists.")

# --- 4. Define Constants and Sports Categories ---
IMG_SIZE = 128
SPATIAL_SEQ_LENGTH = 20
TEMPORAL_SEQ_LENGTH = 10
DATA_DIR = '/content/UCF-101' # This is the source of raw videos

# The list of 63 sports categories to filter
SPORTS_CATEGORIES = [
    'Archery', 'BalanceBeam', 'BaseballPitch', 'BasketballDunk', 'Basketball',
    'BenchPress', 'Biking', 'Billiards', 'Bowling', 'BoxingPunchingBag',
    'BoxingSpeedBag', 'BreastStroke', 'CleanAndJerk', 'CliffDiving', 'CricketBowling',
    'CricketShot', 'Diving', 'Fencing', 'FieldHockeyPenalty', 'FloorGymnastics',
    'FrisbeeCatch', 'FrontCrawl', 'GolfSwing', 'HammerThrow', 'HighJump',
    'HorseRace', 'HorseRiding', 'HulaHoop', 'IceDancing', 'JavelinThrow',
    'JugglingBalls', 'JumpingJack', 'JumpRope', 'Kayaking', 'LongJump',
    'Lunges', 'ParallelBars', 'PoleVault', 'PommelHorse', 'PullUps', 'PushUps',
    'Rafting', 'RockClimbingIndoor', 'RopeClimbing', 'Rowing', 'Shotput',
    'SkateBoarding', 'Skiing', 'Skijet', 'SkyDiving', 'SoccerJuggling',
    'SoccerPenalty', 'StillRings', 'SumoWrestling', 'Surfing', 'TableTennisShot',
    'TaiChi', 'TennisSwing', 'ThrowDiscus', 'TrampolineJumping', 'UnevenBars',
    'VolleyballSpiking', 'YoYo'
]

# --- 5. Define Extraction Functions ---
def extract_frames_spatial(video_path):
    """Extracts evenly-spaced RGB frames from a video."""
    frames = []
    cap = cv2.VideoCapture(video_path)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    if total_frames == 0: return None
    frame_indices = np.linspace(0, total_frames - 1, SPATIAL_SEQ_LENGTH, dtype=int)
    for i in frame_indices:
        cap.set(cv2.CAP_PROP_POS_FRAMES, i)
        ret, frame = cap.read()
        if not ret: frame = np.zeros((IMG_SIZE, IMG_SIZE, 3), dtype=np.float32)
        else:
            frame = cv2.resize(frame, (IMG_SIZE, IMG_SIZE))
            frame = frame / 255.0
        frames.append(frame)
    cap.release()
    return np.array(frames)

def extract_frames_temporal(video_path):
    """Extracts a stack of 10 optical flow fields from a video."""
    frames, flow_fields = [], []
    cap = cv2.VideoCapture(video_path)
    total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    if total_frames < TEMPORAL_SEQ_LENGTH + 1: return None
    start_frame = (total_frames - (TEMPORAL_SEQ_LENGTH + 1)) // 2
    cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
    for i in range(TEMPORAL_SEQ_LENGTH + 1):
        ret, frame = cap.read()
        if not ret: return None
        frame_resized = cv2.resize(frame, (IMG_SIZE, IMG_SIZE))
        gray_frame = cv2.cvtColor(frame_resized, cv2.COLOR_BGR2GRAY)
        frames.append(gray_frame)
    cap.release()
    for i in range(TEMPORAL_SEQ_LENGTH):
        prev_frame, next_frame = frames[i], frames[i+1]
        # Calculate dense optical flow
        flow = cv2.calcOpticalFlowFarneback(prev_frame, next_frame, None, 0.5, 3, 15, 3, 5, 1.2, 0)
        # Normalize the 2-channel flow image to be between 0 and 1
        flow_normalized = cv2.normalize(flow, None, 0, 1, cv2.NORM_MINMAX)
        flow_fields.append(flow_normalized)
    return np.array(flow_fields)

# --- 6. Run the RESUMABLE Pre-processing Loop ---
# This saves the processed .npy files to your Google Drive
OUTPUT_NPY_DIR = "/content/drive/MyDrive/UCF101_Sports_NPY_Full"

if not os.path.exists(OUTPUT_NPY_DIR):
    os.makedirs(OUTPUT_NPY_DIR)
print(f"Saving/Resuming full dataset in: {OUTPUT_NPY_DIR}")

videos_processed = 0
videos_skipped = 0
start_time = time.time()

# Loop over ONLY our 63 sports categories
for class_name in SPORTS_CATEGORIES:
    class_path = os.path.join(DATA_DIR, class_name)
    output_class_dir = os.path.join(OUTPUT_NPY_DIR, class_name)

    if not os.path.exists(output_class_dir):
        os.makedirs(output_class_dir)

    print(f"--- Checking Class: {class_name} ---")

    if not os.path.exists(class_path):
        print(f"Warning: Class folder not found at {class_path}. Skipping.")
        continue

    video_list = os.listdir(class_path)
    for video_name in video_list:
        video_path = os.path.join(class_path, video_name)

        video_base_name = os.path.splitext(video_name)[0]
        spatial_npy_path = os.path.join(output_class_dir, f"{video_base_name}_spatial.npy")
        temporal_npy_path = os.path.join(output_class_dir, f"{video_base_name}_temporal.npy")

        # --- THIS IS THE RESUME LOGIC ---
        # If both files already exist, skip this video
        if os.path.exists(spatial_npy_path) and os.path.exists(temporal_npy_path):
            videos_skipped += 1
            continue # Skip this video, we already processed it

        # --- If not skipped, process it ---
        frames_spatial = extract_frames_spatial(video_path)
        frames_temporal = extract_frames_temporal(video_path)

        if frames_spatial is not None and frames_temporal is not None:
            # Check for correct shapes before saving
            if frames_spatial.shape == (SPATIAL_SEQ_LENGTH, IMG_SIZE, IMG_SIZE, 3) and \
               frames_temporal.shape == (TEMPORAL_SEQ_LENGTH, IMG_SIZE, IMG_SIZE, 2):

                np.save(spatial_npy_path, frames_spatial)
                np.save(temporal_npy_path, frames_temporal)
                videos_processed += 1

        # Print a progress update every 100 videos
        if (videos_processed + videos_skipped) % 100 == 0 and videos_processed > 0:
            print(f"    ...Progress: {videos_processed} new videos processed, {videos_skipped} skipped.")

end_time = time.time()
print("\n--- PRE-PROCESSING BATCH COMPLETE! ---")
print(f"Time taken this session: {(end_time - start_time) / 60:.2f} minutes")
print(f"New videos processed: {videos_processed}")
print(f"Total videos skipped (already done): {videos_skipped}")

print("\n✅✅✅ --- ALL PRE-PROCESSING IS NOW 100% COMPLETE! --- ✅✅✅")
print("You can now proceed to Stage 2.")