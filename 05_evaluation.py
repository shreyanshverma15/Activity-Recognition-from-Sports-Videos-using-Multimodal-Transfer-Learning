# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VUl3lpxc3VfglXZBPngmDL9mTT5ygOsd
"""

import tensorflow as tf
from google.colab import drive
import numpy as np
import os
from sklearn.model_selection import train_test_split
from sklearn.metrics import (
    confusion_matrix,
    multilabel_confusion_matrix,  # This gives you TP/TN/FP/FN
    classification_report
)
import seaborn as sns
import matplotlib.pyplot as plt

# --- 1. Mount Drive and Load Model ---
drive.mount('/content/drive')

print("Loading your BEST saved model from Drive...")
model_path = '/content/drive/MyDrive/fused_model_checkpoint_FULL_FINAL.keras'
fused_model = tf.keras.models.load_model(model_path)
print("Model loaded successfully!")

# --- 2. Re-create the EXACT Test Set ---
print("Scanning for all local .npy files to re-create test split...")
#
# Point to the FAST local folder
#
NPY_DATA_DIR = "/content/UCF101_Sports_NPY_Full"

class_names = sorted(os.listdir(NPY_DATA_DIR))
NUM_CLASSES = len(class_names)

X_spatial_paths = []
X_temporal_paths = []
y_labels = []
label_map = {name: i for i, name in enumerate(class_names)}

for class_name in class_names:
    class_dir = os.path.join(NPY_DATA_DIR, class_name)
    class_label = label_map[class_name]
    for file_name in os.listdir(class_dir):
        if file_name.endswith("_spatial.npy"):
            base_name = file_name.replace("_spatial.npy", "")
            spatial_path = os.path.join(class_dir, file_name)
            temporal_path = os.path.join(class_dir, f"{base_name}_temporal.npy")
            if os.path.exists(temporal_path):
                X_spatial_paths.append(spatial_path)
                X_temporal_paths.append(temporal_path)
                y_labels.append(class_label)

y_categorical = tf.keras.utils.to_categorical(y_labels, num_classes=NUM_CLASSES)

(X_spatial_train, X_spatial_test,
 X_temporal_train, X_temporal_test,
 y_train, y_test) = train_test_split(
    X_spatial_paths, X_temporal_paths, y_categorical,
    test_size=0.2, random_state=42, stratify=y_categorical
)

print(f"Found {len(X_spatial_test)} test samples.")

# --- 3. Define the Data Generator (for the Test Set) ---
def fast_data_generator(spatial_paths, temporal_paths, labels, batch_size):
    num_samples = len(spatial_paths)
    for offset in range(0, num_samples, batch_size):
        batch_indices = list(range(offset, min(offset + batch_size, num_samples)))

        batch_X_spatial = [np.load(spatial_paths[i]) for i in batch_indices]
        batch_X_temporal = [np.load(temporal_paths[i]) for i in batch_indices]
        batch_y = labels[batch_indices]

        yield (
            {'spatial_input': np.array(batch_X_spatial),
             'temporal_input': np.array(batch_X_temporal)},
            np.array(batch_y)
        )

# --- 4. Get All Predictions from the Model ---
BATCH_SIZE = 16
test_steps = int(np.ceil(len(X_spatial_test) / BATCH_SIZE))

test_gen = fast_data_generator(X_spatial_test, X_temporal_test, y_test, BATCH_SIZE)

print("\nGetting model predictions on the test set (this will be fast)...")
y_pred_probs = fused_model.predict(test_gen, steps=test_steps)
y_pred_probs = y_pred_probs[:len(y_test)]
y_pred_labels = np.argmax(y_pred_probs, axis=1)
y_true_labels = np.argmax(y_test, axis=1)

# --- 5. Calculate TP, TN, FP, FN for EACH Class ---
print("\n--- TP/TN/FP/FN per Class (One-vs-Rest) ---")
mcm = multilabel_confusion_matrix(y_true_labels, y_pred_labels, labels=list(range(NUM_CLASSES)))

for i, class_name in enumerate(class_names):
    tn = mcm[i][0][0]
    fp = mcm[i][0][1]
    fn = mcm[i][1][0]
    tp = mcm[i][1][1]
    print(f"\nClass: {class_name}")
    print(f"  True Positives (TP): {tp}")
    print(f"  True Negatives (TN): {tn}")
    print(f"  False Positives (FP): {fp}")
    print(f"  False Negatives (FN): {fn}")

# --- 6. Show Full Classification Report ---
print("\n--- Full Classification Report ---")
print(classification_report(y_true_labels, y_pred_labels, target_names=class_names, zero_division=0))

# --- 7. Plot the 63x63 Confusion Matrix ---
print("\n--- Plotting Full Confusion Matrix ---")
cm = confusion_matrix(y_true_labels, y_pred_labels)

plt.figure(figsize=(20, 20))
sns.heatmap(cm, annot=False, cmap='viridis_r',
            xticklabels=class_names, yticklabels=class_names)
plt.title('Confusion Matrix (Actual vs. Predicted)', fontsize=20)
plt.xlabel('Predicted Label', fontsize=16)
plt.ylabel('Actual Label', fontsize=16)
plt.show()